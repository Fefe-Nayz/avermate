diff --git a/node_modules/vaul/dist/index.js b/node_modules/vaul/dist/index.js
index 9168042..bbd71a7 100644
--- a/node_modules/vaul/dist/index.js
+++ b/node_modules/vaul/dist/index.js
@@ -1,11 +1,11 @@
 'use client';
 function __insertCSS(code) {
-  if (!code || typeof document == 'undefined') return
-  let head = document.head || document.getElementsByTagName('head')[0]
-  let style = document.createElement('style')
-  style.type = 'text/css'
-  head.appendChild(style)
-  ;style.styleSheet ? (style.styleSheet.cssText = code) : style.appendChild(document.createTextNode(code))
+    if (!code || typeof document == 'undefined') return
+    let head = document.head || document.getElementsByTagName('head')[0]
+    let style = document.createElement('style')
+    style.type = 'text/css'
+    head.appendChild(style)
+        ; style.styleSheet ? (style.styleSheet.cssText = code) : style.appendChild(document.createTextNode(code))
 }
 
 Object.defineProperty(exports, '__esModule', { value: true });
@@ -14,21 +14,21 @@ var DialogPrimitive = require('@radix-ui/react-dialog');
 var React = require('react');
 
 function _interopNamespace(e) {
-  if (e && e.__esModule) return e;
-  var n = Object.create(null);
-  if (e) {
-    Object.keys(e).forEach(function (k) {
-      if (k !== 'default') {
-        var d = Object.getOwnPropertyDescriptor(e, k);
-        Object.defineProperty(n, k, d.get ? d : {
-          enumerable: true,
-          get: function () { return e[k]; }
+    if (e && e.__esModule) return e;
+    var n = Object.create(null);
+    if (e) {
+        Object.keys(e).forEach(function (k) {
+            if (k !== 'default') {
+                var d = Object.getOwnPropertyDescriptor(e, k);
+                Object.defineProperty(n, k, d.get ? d : {
+                    enumerable: true,
+                    get: function () { return e[k]; }
+                });
+            }
         });
-      }
-    });
-  }
-  n.default = e;
-  return n;
+    }
+    n.default = e;
+    return n;
 }
 
 var DialogPrimitive__namespace = /*#__PURE__*/_interopNamespace(DialogPrimitive);
@@ -41,12 +41,12 @@ const DrawerContext = React__namespace.default.createContext({
     overlayRef: {
         current: null
     },
-    onPress: ()=>{},
-    onRelease: ()=>{},
-    onDrag: ()=>{},
-    onNestedDrag: ()=>{},
-    onNestedOpenChange: ()=>{},
-    onNestedRelease: ()=>{},
+    onPress: () => { },
+    onRelease: () => { },
+    onDrag: () => { },
+    onNestedDrag: () => { },
+    onNestedOpenChange: () => { },
+    onNestedRelease: () => { },
     openProp: undefined,
     dismissible: false,
     isOpen: false,
@@ -60,9 +60,9 @@ const DrawerContext = React__namespace.default.createContext({
     modal: false,
     shouldFade: false,
     activeSnapPoint: null,
-    onOpenChange: ()=>{},
-    setActiveSnapPoint: ()=>{},
-    closeDrawer: ()=>{},
+    onOpenChange: () => { },
+    setActiveSnapPoint: () => { },
+    closeDrawer: () => { },
     direction: 'bottom',
     shouldAnimate: {
         current: true
@@ -73,7 +73,7 @@ const DrawerContext = React__namespace.default.createContext({
     container: null,
     autoFocus: false
 });
-const useDrawerContext = ()=>{
+const useDrawerContext = () => {
     const context = React__namespace.default.useContext(DrawerContext);
     if (!context) {
         throw new Error('useDrawerContext must be used within a Drawer.Root');
@@ -86,7 +86,7 @@ __insertCSS("[data-vaul-drawer]{touch-action:none;will-change:transform;transiti
 function isMobileFirefox() {
     const userAgent = navigator.userAgent;
     return typeof window !== 'undefined' && (/Firefox/.test(userAgent) && /Mobile/.test(userAgent) || // Android Firefox
-    /FxiOS/.test(userAgent) // iOS Firefox
+        /FxiOS/.test(userAgent) // iOS Firefox
     );
 }
 function isMac() {
@@ -100,7 +100,7 @@ function isSafari() {
 }
 function isIPad() {
     return testPlatform(/^iPad/) || // iPadOS 13 lies and says it's a Mac, but we can distinguish by detecting touch support.
-    isMac() && navigator.maxTouchPoints > 1;
+        isMac() && navigator.maxTouchPoints > 1;
 }
 function isIOS() {
     return isIPhone() || isIPad();
@@ -113,8 +113,8 @@ function testPlatform(re) {
 const KEYBOARD_BUFFER = 24;
 const useIsomorphicLayoutEffect = typeof window !== 'undefined' ? React.useLayoutEffect : React.useEffect;
 function chain$1(...callbacks) {
-    return (...args)=>{
-        for (let callback of callbacks){
+    return (...args) => {
+        for (let callback of callbacks) {
             if (typeof callback === 'function') {
                 callback(...args);
             }
@@ -131,7 +131,7 @@ function getScrollParent(node) {
     if (isScrollable(node)) {
         node = node.parentElement;
     }
-    while(node && !isScrollable(node)){
+    while (node && !isScrollable(node)) {
         node = node.parentElement;
     }
     return node || document.scrollingElement || document.documentElement;
@@ -157,7 +157,7 @@ let restore;
  * shift due to the scrollbars disappearing.
  */ function usePreventScroll(options = {}) {
     let { isDisabled } = options;
-    useIsomorphicLayoutEffect(()=>{
+    useIsomorphicLayoutEffect(() => {
         if (isDisabled) {
             return;
         }
@@ -167,7 +167,7 @@ let restore;
                 restore = preventScrollMobileSafari();
             }
         }
-        return ()=>{
+        return () => {
             preventScrollCount--;
             if (preventScrollCount === 0) {
                 restore == null ? void 0 : restore();
@@ -206,7 +206,7 @@ let restore;
 function preventScrollMobileSafari() {
     let scrollable;
     let lastY = 0;
-    let onTouchStart = (e)=>{
+    let onTouchStart = (e) => {
         // Store the nearest scrollable parent element from the element that the user touched.
         scrollable = getScrollParent(e.target);
         if (scrollable === document.documentElement && scrollable === document.body) {
@@ -214,7 +214,7 @@ function preventScrollMobileSafari() {
         }
         lastY = e.changedTouches[0].pageY;
     };
-    let onTouchMove = (e)=>{
+    let onTouchMove = (e) => {
         // Prevent scrolling the window.
         if (!scrollable || scrollable === document.documentElement || scrollable === document.body) {
             e.preventDefault();
@@ -235,7 +235,7 @@ function preventScrollMobileSafari() {
         }
         lastY = y;
     };
-    let onTouchEnd = (e)=>{
+    let onTouchEnd = (e) => {
         let target = e.target;
         // Apply this change if we're not already focused on the target element
         if (isInput(target) && target !== document.activeElement) {
@@ -245,12 +245,12 @@ function preventScrollMobileSafari() {
             // be done before the "focus" event, so we have to focus the element ourselves.
             target.style.transform = 'translateY(-2000px)';
             target.focus();
-            requestAnimationFrame(()=>{
+            requestAnimationFrame(() => {
                 target.style.transform = '';
             });
         }
     };
-    let onFocus = (e)=>{
+    let onFocus = (e) => {
         let target = e.target;
         if (isInput(target)) {
             // Transform also needs to be applied in the focus event in cases where focus moves
@@ -258,7 +258,7 @@ function preventScrollMobileSafari() {
             // software keyboard. In these cases, it seems applying the transform in the focus event
             // is good enough, whereas when tapping an input, it must be done before the focus event. 🤷‍♂️
             target.style.transform = 'translateY(-2000px)';
-            requestAnimationFrame(()=>{
+            requestAnimationFrame(() => {
                 target.style.transform = '';
                 // This will have prevented the browser from scrolling the focused element into view,
                 // so we need to do this ourselves in a way that doesn't cause the whole page to scroll.
@@ -266,13 +266,13 @@ function preventScrollMobileSafari() {
                     if (visualViewport.height < window.innerHeight) {
                         // If the keyboard is already visible, do this after one additional frame
                         // to wait for the transform to be removed.
-                        requestAnimationFrame(()=>{
+                        requestAnimationFrame(() => {
                             scrollIntoView(target);
                         });
                     } else {
                         // Otherwise, wait for the visual viewport to resize before scrolling so we can
                         // measure the correct position to scroll to.
-                        visualViewport.addEventListener('resize', ()=>scrollIntoView(target), {
+                        visualViewport.addEventListener('resize', () => scrollIntoView(target), {
                             once: true
                         });
                     }
@@ -280,7 +280,7 @@ function preventScrollMobileSafari() {
             });
         }
     };
-    let onWindowScroll = ()=>{
+    let onWindowScroll = () => {
         // Last resort. If the window scrolled, scroll it back to the top.
         // It should always be at the top because the body will have a negative margin (see below).
         window.scrollTo(0, 0);
@@ -303,7 +303,7 @@ function preventScrollMobileSafari() {
         passive: false,
         capture: true
     }), addEvent(document, 'focus', onFocus, true), addEvent(window, 'scroll', onWindowScroll));
-    return ()=>{
+    return () => {
         // Restore styles and scroll the page back to where it was.
         restoreStyles();
         removeEvents();
@@ -317,7 +317,7 @@ function setStyle(element, style, value) {
     let cur = element.style[style];
     // @ts-ignore
     element.style[style] = value;
-    return ()=>{
+    return () => {
         // @ts-ignore
         element.style[style] = cur;
     };
@@ -326,14 +326,14 @@ function setStyle(element, style, value) {
 function addEvent(target, event, handler, options) {
     // @ts-ignore
     target.addEventListener(event, handler, options);
-    return ()=>{
+    return () => {
         // @ts-ignore
         target.removeEventListener(event, handler, options);
     };
 }
 function scrollIntoView(target) {
     let root = document.scrollingElement || document.documentElement;
-    while(target && target !== root){
+    while (target && target !== root) {
         // Find the parent scrollable element and adjust the scroll position if the target is not already in view.
         let scrollable = getScrollParent(target);
         if (scrollable !== document.documentElement && scrollable !== document.body && scrollable !== target) {
@@ -369,7 +369,7 @@ function isInput(target) {
  * A utility to compose multiple refs together
  * Accepts callback refs and RefObject(s)
  */ function composeRefs(...refs) {
-    return (node)=>refs.forEach((ref)=>setRef(ref, node));
+    return (node) => refs.forEach((ref) => setRef(ref, node));
 }
 /**
  * A custom hook that composes multiple refs
@@ -383,7 +383,7 @@ const cache = new WeakMap();
 function set(el, styles, ignoreCache = false) {
     if (!el || !(el instanceof HTMLElement)) return;
     let originalStyles = {};
-    Object.entries(styles).forEach(([key, value])=>{
+    Object.entries(styles).forEach(([key, value]) => {
         if (key.startsWith('--')) {
             el.style.setProperty(key, value);
             return;
@@ -404,8 +404,8 @@ function reset(el, prop) {
         el.style[prop] = originalStyles[prop];
     }
 }
-const isVertical = (direction)=>{
-    switch(direction){
+const isVertical = (direction) => {
+    switch (direction) {
         case 'top':
         case 'bottom':
             return true;
@@ -422,7 +422,7 @@ function getTranslate(element, direction) {
     }
     const style = window.getComputedStyle(element);
     const transform = // @ts-ignore
-    style.transform || style.webkitTransform || style.mozTransform;
+        style.transform || style.webkitTransform || style.mozTransform;
     let mat = transform.match(/^matrix3d\((.+)\)$/);
     if (mat) {
         // https://developer.mozilla.org/en-US/docs/Web/CSS/transform-function/matrix3d
@@ -436,18 +436,18 @@ function dampenValue(v) {
     return 8 * (Math.log(v + 1) - 2);
 }
 function assignStyle(element, style) {
-    if (!element) return ()=>{};
+    if (!element) return () => { };
     const prevStyle = element.style.cssText;
     Object.assign(element.style, style);
-    return ()=>{
+    return () => {
         element.style.cssText = prevStyle;
     };
 }
 /**
  * Receives functions as arguments and returns a new function that calls all.
  */ function chain(...fns) {
-    return (...args)=>{
-        for (const fn of fns){
+    return (...args) => {
+        for (const fn of fns) {
             if (typeof fn === 'function') {
                 // @ts-ignore
                 fn(...args);
@@ -476,18 +476,18 @@ const DRAG_CLASS = 'vaul-dragging';
 // This code comes from https://github.com/radix-ui/primitives/blob/main/packages/react/use-controllable-state/src/useControllableState.tsx
 function useCallbackRef(callback) {
     const callbackRef = React__namespace.default.useRef(callback);
-    React__namespace.default.useEffect(()=>{
+    React__namespace.default.useEffect(() => {
         callbackRef.current = callback;
     });
     // https://github.com/facebook/react/issues/19240
-    return React__namespace.default.useMemo(()=>(...args)=>callbackRef.current == null ? void 0 : callbackRef.current.call(callbackRef, ...args), []);
+    return React__namespace.default.useMemo(() => (...args) => callbackRef.current == null ? void 0 : callbackRef.current.call(callbackRef, ...args), []);
 }
 function useUncontrolledState({ defaultProp, onChange }) {
     const uncontrolledState = React__namespace.default.useState(defaultProp);
     const [value] = uncontrolledState;
     const prevValueRef = React__namespace.default.useRef(value);
     const handleChange = useCallbackRef(onChange);
-    React__namespace.default.useEffect(()=>{
+    React__namespace.default.useEffect(() => {
         if (prevValueRef.current !== value) {
             handleChange(value);
             prevValueRef.current = value;
@@ -499,7 +499,7 @@ function useUncontrolledState({ defaultProp, onChange }) {
     ]);
     return uncontrolledState;
 }
-function useControllableState({ prop, defaultProp, onChange = ()=>{} }) {
+function useControllableState({ prop, defaultProp, onChange = () => { } }) {
     const [uncontrolledProp, setUncontrolledProp] = useUncontrolledState({
         defaultProp,
         onChange
@@ -507,7 +507,7 @@ function useControllableState({ prop, defaultProp, onChange = ()=>{} }) {
     const isControlled = prop !== undefined;
     const value = isControlled ? prop : uncontrolledProp;
     const handleChange = useCallbackRef(onChange);
-    const setValue = React__namespace.default.useCallback((nextValue)=>{
+    const setValue = React__namespace.default.useCallback((nextValue) => {
         if (isControlled) {
             const setter = nextValue;
             const value = typeof nextValue === 'function' ? setter(prop) : nextValue;
@@ -537,7 +537,7 @@ function useSnapPoints({ activeSnapPointProp, setActiveSnapPointProp, snapPoints
         innerWidth: window.innerWidth,
         innerHeight: window.innerHeight
     } : undefined);
-    React__namespace.default.useEffect(()=>{
+    React__namespace.default.useEffect(() => {
         function onResize() {
             setWindowDimensions({
                 innerWidth: window.innerWidth,
@@ -545,21 +545,21 @@ function useSnapPoints({ activeSnapPointProp, setActiveSnapPointProp, snapPoints
             });
         }
         window.addEventListener('resize', onResize);
-        return ()=>window.removeEventListener('resize', onResize);
+        return () => window.removeEventListener('resize', onResize);
     }, []);
-    const isLastSnapPoint = React__namespace.default.useMemo(()=>activeSnapPoint === (snapPoints == null ? void 0 : snapPoints[snapPoints.length - 1]) || null, [
+    const isLastSnapPoint = React__namespace.default.useMemo(() => activeSnapPoint === (snapPoints == null ? void 0 : snapPoints[snapPoints.length - 1]) || null, [
         snapPoints,
         activeSnapPoint
     ]);
-    const activeSnapPointIndex = React__namespace.default.useMemo(()=>{
+    const activeSnapPointIndex = React__namespace.default.useMemo(() => {
         var _snapPoints_findIndex;
-        return (_snapPoints_findIndex = snapPoints == null ? void 0 : snapPoints.findIndex((snapPoint)=>snapPoint === activeSnapPoint)) != null ? _snapPoints_findIndex : null;
+        return (_snapPoints_findIndex = snapPoints == null ? void 0 : snapPoints.findIndex((snapPoint) => snapPoint === activeSnapPoint)) != null ? _snapPoints_findIndex : null;
     }, [
         snapPoints,
         activeSnapPoint
     ]);
     const shouldFade = snapPoints && snapPoints.length > 0 && (fadeFromIndex || fadeFromIndex === 0) && !Number.isNaN(fadeFromIndex) && snapPoints[fadeFromIndex] === activeSnapPoint || !snapPoints;
-    const snapPointsOffset = React__namespace.default.useMemo(()=>{
+    const snapPointsOffset = React__namespace.default.useMemo(() => {
         const containerSize = container ? {
             width: container.getBoundingClientRect().width,
             height: container.getBoundingClientRect().height
@@ -571,7 +571,7 @@ function useSnapPoints({ activeSnapPointProp, setActiveSnapPointProp, snapPoints
             height: 0
         };
         var _snapPoints_map;
-        return (_snapPoints_map = snapPoints == null ? void 0 : snapPoints.map((snapPoint)=>{
+        return (_snapPoints_map = snapPoints == null ? void 0 : snapPoints.map((snapPoint) => {
             const isPx = typeof snapPoint === 'string';
             let snapPointAsNumber = 0;
             if (isPx) {
@@ -595,13 +595,13 @@ function useSnapPoints({ activeSnapPointProp, setActiveSnapPointProp, snapPoints
         windowDimensions,
         container
     ]);
-    const activeSnapPointOffset = React__namespace.default.useMemo(()=>activeSnapPointIndex !== null ? snapPointsOffset == null ? void 0 : snapPointsOffset[activeSnapPointIndex] : null, [
+    const activeSnapPointOffset = React__namespace.default.useMemo(() => activeSnapPointIndex !== null ? snapPointsOffset == null ? void 0 : snapPointsOffset[activeSnapPointIndex] : null, [
         snapPointsOffset,
         activeSnapPointIndex
     ]);
-    const snapToPoint = React__namespace.default.useCallback((dimension)=>{
+    const snapToPoint = React__namespace.default.useCallback((dimension) => {
         var _snapPointsOffset_findIndex;
-        const newSnapPointIndex = (_snapPointsOffset_findIndex = snapPointsOffset == null ? void 0 : snapPointsOffset.findIndex((snapPointDim)=>snapPointDim === dimension)) != null ? _snapPointsOffset_findIndex : null;
+        const newSnapPointIndex = (_snapPointsOffset_findIndex = snapPointsOffset == null ? void 0 : snapPointsOffset.findIndex((snapPointDim) => snapPointDim === dimension)) != null ? _snapPointsOffset_findIndex : null;
         onSnapPointChange(newSnapPointIndex);
         set(drawerRef.current, {
             transition: `transform ${TRANSITIONS.DURATION}s cubic-bezier(${TRANSITIONS.EASE.join(',')})`,
@@ -627,10 +627,10 @@ function useSnapPoints({ activeSnapPointProp, setActiveSnapPointProp, snapPoints
         overlayRef,
         setActiveSnapPoint
     ]);
-    React__namespace.default.useEffect(()=>{
+    React__namespace.default.useEffect(() => {
         if (activeSnapPoint || activeSnapPointProp) {
             var _snapPoints_findIndex;
-            const newIndex = (_snapPoints_findIndex = snapPoints == null ? void 0 : snapPoints.findIndex((snapPoint)=>snapPoint === activeSnapPointProp || snapPoint === activeSnapPoint)) != null ? _snapPoints_findIndex : -1;
+            const newIndex = (_snapPoints_findIndex = snapPoints == null ? void 0 : snapPoints.findIndex((snapPoint) => snapPoint === activeSnapPointProp || snapPoint === activeSnapPoint)) != null ? _snapPoints_findIndex : -1;
             if (snapPointsOffset && newIndex !== -1 && typeof snapPointsOffset[newIndex] === 'number') {
                 snapToPoint(snapPointsOffset[newIndex]);
             }
@@ -663,7 +663,7 @@ function useSnapPoints({ activeSnapPointProp, setActiveSnapPointProp, snapPoints
             return;
         }
         // Find the closest snap point to the current position
-        const closestSnapPoint = snapPointsOffset == null ? void 0 : snapPointsOffset.reduce((prev, curr)=>{
+        const closestSnapPoint = snapPointsOffset == null ? void 0 : snapPointsOffset.reduce((prev, curr) => {
             if (typeof prev !== 'number' || typeof curr !== 'number') return prev;
             return Math.abs(curr - currentPosition) < Math.abs(prev - currentPosition) ? curr : prev;
         });
@@ -733,15 +733,15 @@ function useSnapPoints({ activeSnapPointProp, setActiveSnapPointProp, snapPoints
     };
 }
 
-const noop = ()=>()=>{};
+const noop = () => () => { };
 function useScaleBackground() {
     const { direction, isOpen, shouldScaleBackground, setBackgroundColorOnScale, noBodyStyles } = useDrawerContext();
     const timeoutIdRef = React__namespace.default.useRef(null);
-    const initialBackgroundColor = React.useMemo(()=>document.body.style.backgroundColor, []);
+    const initialBackgroundColor = React.useMemo(() => document.body.style.backgroundColor, []);
     function getScale() {
         return (window.innerWidth - WINDOW_TOP_OFFSET) / window.innerWidth;
     }
-    React__namespace.default.useEffect(()=>{
+    React__namespace.default.useEffect(() => {
         if (isOpen && shouldScaleBackground) {
             if (timeoutIdRef.current) clearTimeout(timeoutIdRef.current);
             const wrapper = document.querySelector('[data-vaul-drawer-wrapper]') || document.querySelector('[vaul-drawer-wrapper]');
@@ -763,9 +763,9 @@ function useScaleBackground() {
                     transform: `scale(${getScale()}) translate3d(calc(env(safe-area-inset-top) + 14px), 0, 0)`
                 }
             });
-            return ()=>{
+            return () => {
                 wrapperStylesCleanup();
-                timeoutIdRef.current = window.setTimeout(()=>{
+                timeoutIdRef.current = window.setTimeout(() => {
                     if (initialBackgroundColor) {
                         document.body.style.background = initialBackgroundColor;
                     } else {
@@ -790,9 +790,9 @@ let previousBodyPosition = null;
  * https://github.com/emilkowalski/vaul/issues/433
  * And more that I discovered, but were just not reported.
  */ function usePositionFixed({ isOpen, modal, nested, hasBeenOpened, preventScrollRestoration, noBodyStyles }) {
-    const [activeUrl, setActiveUrl] = React__namespace.default.useState(()=>typeof window !== 'undefined' ? window.location.href : '');
+    const [activeUrl, setActiveUrl] = React__namespace.default.useState(() => typeof window !== 'undefined' ? window.location.href : '');
     const scrollPos = React__namespace.default.useRef(0);
-    const setPositionFixed = React__namespace.default.useCallback(()=>{
+    const setPositionFixed = React__namespace.default.useCallback(() => {
         // All browsers on iOS will return true here.
         if (!isSafari()) return;
         // If previousBodyPosition is already set, don't set it again.
@@ -813,19 +813,19 @@ let previousBodyPosition = null;
                 right: '0px',
                 height: 'auto'
             });
-            window.setTimeout(()=>window.requestAnimationFrame(()=>{
-                    // Attempt to check if the bottom bar appeared due to the position change
-                    const bottomBarHeight = innerHeight - window.innerHeight;
-                    if (bottomBarHeight && scrollPos.current >= innerHeight) {
-                        // Move the content further up so that the bottom bar doesn't hide it
-                        document.body.style.top = `${-(scrollPos.current + bottomBarHeight)}px`;
-                    }
-                }), 300);
+            window.setTimeout(() => window.requestAnimationFrame(() => {
+                // Attempt to check if the bottom bar appeared due to the position change
+                const bottomBarHeight = innerHeight - window.innerHeight;
+                if (bottomBarHeight && scrollPos.current >= innerHeight) {
+                    // Move the content further up so that the bottom bar doesn't hide it
+                    document.body.style.top = `${-(scrollPos.current + bottomBarHeight)}px`;
+                }
+            }), 300);
         }
     }, [
         isOpen
     ]);
-    const restorePositionSetting = React__namespace.default.useCallback(()=>{
+    const restorePositionSetting = React__namespace.default.useCallback(() => {
         // All browsers on iOS will return true here.
         if (!isSafari()) return;
         if (previousBodyPosition !== null && !noBodyStyles) {
@@ -834,7 +834,7 @@ let previousBodyPosition = null;
             const x = -parseInt(document.body.style.left, 10);
             // Restore styles
             Object.assign(document.body.style, previousBodyPosition);
-            window.requestAnimationFrame(()=>{
+            window.requestAnimationFrame(() => {
                 if (preventScrollRestoration && activeUrl !== window.location.href) {
                     setActiveUrl(window.location.href);
                     return;
@@ -846,19 +846,19 @@ let previousBodyPosition = null;
     }, [
         activeUrl
     ]);
-    React__namespace.default.useEffect(()=>{
+    React__namespace.default.useEffect(() => {
         function onScroll() {
             scrollPos.current = window.scrollY;
         }
         onScroll();
         window.addEventListener('scroll', onScroll);
-        return ()=>{
+        return () => {
             window.removeEventListener('scroll', onScroll);
         };
     }, []);
-    React__namespace.default.useEffect(()=>{
+    React__namespace.default.useEffect(() => {
         if (!modal) return;
-        return ()=>{
+        return () => {
             if (typeof document === 'undefined') return;
             // Another drawer is opened, safe to ignore the execution
             const hasDrawerOpened = !!document.querySelector('[data-vaul-drawer]');
@@ -869,7 +869,7 @@ let previousBodyPosition = null;
         modal,
         restorePositionSetting
     ]);
-    React__namespace.default.useEffect(()=>{
+    React__namespace.default.useEffect(() => {
         if (nested || !hasBeenOpened) return;
         // This is needed to force Safari toolbar to show **before** the drawer starts animating to prevent a gnarly shift from happening
         if (isOpen) {
@@ -877,7 +877,7 @@ let previousBodyPosition = null;
             const isStandalone = window.matchMedia('(display-mode: standalone)').matches;
             !isStandalone && setPositionFixed();
             if (!modal) {
-                window.setTimeout(()=>{
+                window.setTimeout(() => {
                     restorePositionSetting();
                 }, 500);
             }
@@ -903,17 +903,17 @@ function Root({ open: openProp, onOpenChange, children, onDrag: onDragProp, onRe
     const [isOpen = false, setIsOpen] = useControllableState({
         defaultProp: defaultOpen,
         prop: openProp,
-        onChange: (o)=>{
+        onChange: (o) => {
             onOpenChange == null ? void 0 : onOpenChange(o);
             if (!o && !nested) {
                 restorePositionSetting();
             }
-            setTimeout(()=>{
+            setTimeout(() => {
                 onAnimationEnd == null ? void 0 : onAnimationEnd(o);
             }, TRANSITIONS.DURATION * 1000);
             if (o && !modal) {
                 if (typeof window !== 'undefined') {
-                    window.requestAnimationFrame(()=>{
+                    window.requestAnimationFrame(() => {
                         document.body.style.pointerEvents = 'auto';
                     });
                 }
@@ -942,7 +942,7 @@ function Root({ open: openProp, onOpenChange, children, onDrag: onDragProp, onRe
     const drawerHeightRef = React__namespace.default.useRef(((_drawerRef_current = drawerRef.current) == null ? void 0 : _drawerRef_current.getBoundingClientRect().height) || 0);
     const drawerWidthRef = React__namespace.default.useRef(((_drawerRef_current1 = drawerRef.current) == null ? void 0 : _drawerRef_current1.getBoundingClientRect().width) || 0);
     const initialDrawerHeight = React__namespace.default.useRef(0);
-    const onSnapPointChange = React__namespace.default.useCallback((activeSnapPointIndex)=>{
+    const onSnapPointChange = React__namespace.default.useCallback((activeSnapPointIndex) => {
         // Change openTime ref when we reach the last snap point to prevent dragging for 500ms incase it's scrollable.
         if (snapPoints && activeSnapPointIndex === snapPointsOffset.length - 1) openTime.current = new Date();
     }, []);
@@ -982,7 +982,7 @@ function Root({ open: openProp, onOpenChange, children, onDrag: onDragProp, onRe
         dragStartTime.current = new Date();
         // iOS doesn't trigger mouseUp after scrolling so we need to listen to touched in order to disallow dragging
         if (isIOS()) {
-            window.addEventListener('touchend', ()=>isAllowedToDrag.current = false, {
+            window.addEventListener('touchend', () => isAllowedToDrag.current = false, {
                 once: true
             });
         }
@@ -1030,7 +1030,7 @@ function Root({ open: openProp, onOpenChange, children, onDrag: onDragProp, onRe
             return false;
         }
         // Keep climbing up the DOM tree as long as there's a parent
-        while(element){
+        while (element) {
             // Check if the element is scrollable
             if (element.scrollHeight > element.clientHeight) {
                 if (element.scrollTop !== 0) {
@@ -1126,79 +1126,109 @@ function Root({ open: openProp, onOpenChange, children, onDrag: onDragProp, onRe
             }
         }
     }
-    React__namespace.default.useEffect(()=>{
-        window.requestAnimationFrame(()=>{
+    React__namespace.default.useEffect(() => {
+        window.requestAnimationFrame(() => {
             shouldAnimate.current = true;
         });
     }, []);
-    React__namespace.default.useEffect(()=>{
-        var _window_visualViewport;
+    React__namespace.default.useEffect(() => {
         function onVisualViewportChange() {
             if (!drawerRef.current || !repositionInputs) return;
+
             const focusedElement = document.activeElement;
+
+            // If the focused element is an input OR we've previously detected the keyboard is open,
+            // go ahead and do the positioning logic.
             if (isInput(focusedElement) || keyboardIsOpen.current) {
-                var _window_visualViewport;
-                const visualViewportHeight = ((_window_visualViewport = window.visualViewport) == null ? void 0 : _window_visualViewport.height) || 0;
+                const visualViewportHeight = window.visualViewport?.height || 0;
                 const totalHeight = window.innerHeight;
-                // This is the height of the keyboard
-                let diffFromInitial = totalHeight - visualViewportHeight;
+                let diffFromInitial = totalHeight - visualViewportHeight; // "keyboard height"
                 const drawerHeight = drawerRef.current.getBoundingClientRect().height || 0;
-                // Adjust drawer height only if it's tall enough
-                const isTallEnough = drawerHeight > totalHeight * 0.8;
+
+                // If we haven’t stored the initial drawer height yet, store it
                 if (!initialDrawerHeight.current) {
                     initialDrawerHeight.current = drawerHeight;
                 }
+
                 const offsetFromTop = drawerRef.current.getBoundingClientRect().top;
-                // visualViewport height may change due to somq e subtle changes to the keyboard. Checking if the height changed by 60 or more will make sure that they keyboard really changed its open state.
-                if (Math.abs(previousDiffFromInitial.current - diffFromInitial) > 60) {
-                    keyboardIsOpen.current = !keyboardIsOpen.current;
-                }
-                if (snapPoints && snapPoints.length > 0 && snapPointsOffset && activeSnapPointIndex) {
+                const isTallEnough = drawerHeight > totalHeight * 0.8;
+
+                // If you’d like to treat *any* notable difference as "keyboard open",
+                // use a small threshold. For instance, 20px or 30px.
+                // This helps capture partial or subtle keyboard size changes.
+                const KEYBOARD_OPEN_THRESHOLD = 20;
+
+                // Overwrite the old "if (Math.abs(...) > 60)" approach.
+                // Instead, determine if the keyboard is "open" based on the current diff.
+                keyboardIsOpen.current = diffFromInitial > KEYBOARD_OPEN_THRESHOLD;
+
+                // If you want to *always* re-measure with no threshold at all, you could do:
+                // keyboardIsOpen.current = diffFromInitial > 0;
+
+                // If snap points exist, adjust the diff accordingly.
+                if (snapPoints && snapPoints.length > 0 && snapPointsOffset && activeSnapPointIndex !== undefined) {
                     const activeSnapPointHeight = snapPointsOffset[activeSnapPointIndex] || 0;
                     diffFromInitial += activeSnapPointHeight;
                 }
+
                 previousDiffFromInitial.current = diffFromInitial;
-                // We don't have to change the height if the input is in view, when we are here we are in the opened keyboard state so we can correctly check if the input is in view
+
+                // If the drawer is taller than the visible area OR the keyboard is open, we shrink it
                 if (drawerHeight > visualViewportHeight || keyboardIsOpen.current) {
-                    const height = drawerRef.current.getBoundingClientRect().height;
-                    let newDrawerHeight = height;
-                    if (height > visualViewportHeight) {
+                    const currentHeight = drawerRef.current.getBoundingClientRect().height;
+                    let newDrawerHeight = currentHeight;
+
+                    // If the drawer is taller than the viewport, shrink it
+                    if (currentHeight > visualViewportHeight) {
+                        // Use top offset if the drawer is "tall enough," otherwise a constant offset
                         newDrawerHeight = visualViewportHeight - (isTallEnough ? offsetFromTop : WINDOW_TOP_OFFSET);
                     }
-                    // When fixed, don't move the drawer upwards if there's space, but rather only change it's height so it's fully scrollable when the keyboard is open
+
                     if (fixed) {
-                        drawerRef.current.style.height = `${height - Math.max(diffFromInitial, 0)}px`;
+                        // "Fixed" logic: only modify the height by subtracting the keyboard difference,
+                        // enabling scroll within the drawer if needed
+                        drawerRef.current.style.height = `${currentHeight - Math.max(diffFromInitial, 0)}px`;
                     } else {
+                        // "Absolute/relative" logic: ensure the drawer fits within the viewport
                         drawerRef.current.style.height = `${Math.max(newDrawerHeight, visualViewportHeight - offsetFromTop)}px`;
                     }
-                } else if (!isMobileFirefox()) {
+                }
+                // If the keyboard is closed and we’re not on mobile Firefox, reset to original height
+                else if (!isMobileFirefox()) {
                     drawerRef.current.style.height = `${initialDrawerHeight.current}px`;
                 }
+
+                // Adjust bottom offset. If the keyboard is closed, bottom = 0. Otherwise, shift it up.
                 if (snapPoints && snapPoints.length > 0 && !keyboardIsOpen.current) {
-                    drawerRef.current.style.bottom = `0px`;
+                    drawerRef.current.style.bottom = '0px';
                 } else {
-                    // Negative bottom value would never make sense
                     drawerRef.current.style.bottom = `${Math.max(diffFromInitial, 0)}px`;
                 }
             }
         }
-        (_window_visualViewport = window.visualViewport) == null ? void 0 : _window_visualViewport.addEventListener('resize', onVisualViewportChange);
-        return ()=>{
-            var _window_visualViewport;
-            return (_window_visualViewport = window.visualViewport) == null ? void 0 : _window_visualViewport.removeEventListener('resize', onVisualViewportChange);
+
+        // Attach the event listener for viewport resizing
+        window.visualViewport?.addEventListener('resize', onVisualViewportChange);
+
+        return () => {
+            // Cleanup
+            window.visualViewport?.removeEventListener('resize', onVisualViewportChange);
         };
     }, [
         activeSnapPointIndex,
         snapPoints,
-        snapPointsOffset
+        snapPointsOffset,
+        repositionInputs,
+        fixed
     ]);
+
     function closeDrawer(fromWithin) {
         cancelDrag();
         onClose == null ? void 0 : onClose();
         if (!fromWithin) {
             setIsOpen(false);
         }
-        setTimeout(()=>{
+        setTimeout(() => {
             if (snapPoints) {
                 setActiveSnapPoint(snapPoints[0]);
             }
@@ -1256,7 +1286,7 @@ function Root({ open: openProp, onOpenChange, children, onDrag: onDragProp, onRe
         if (velocity > 0.05) {
             // `justReleased` is needed to prevent the drawer from focusing on an input when the drag ends, as it's not the intent most of the time.
             setJustReleased(true);
-            setTimeout(()=>{
+            setTimeout(() => {
                 setJustReleased(false);
             }, 200);
         }
@@ -1295,7 +1325,7 @@ function Root({ open: openProp, onOpenChange, children, onDrag: onDragProp, onRe
         onReleaseProp == null ? void 0 : onReleaseProp(event, true);
         resetDrawer();
     }
-    React__namespace.default.useEffect(()=>{
+    React__namespace.default.useEffect(() => {
         // Trigger enter animation without using CSS animation
         if (isOpen) {
             set(document.documentElement, {
@@ -1303,7 +1333,7 @@ function Root({ open: openProp, onOpenChange, children, onDrag: onDragProp, onRe
             });
             openTime.current = new Date();
         }
-        return ()=>{
+        return () => {
             reset(document.documentElement, 'scrollBehavior');
         };
     }, [
@@ -1320,7 +1350,7 @@ function Root({ open: openProp, onOpenChange, children, onDrag: onDragProp, onRe
             transform: isVertical(direction) ? `scale(${scale}) translate3d(0, ${initialTranslate}px, 0)` : `scale(${scale}) translate3d(${initialTranslate}, 0, 0)`
         });
         if (!o && drawerRef.current) {
-            nestedOpenChangeTimer.current = setTimeout(()=>{
+            nestedOpenChangeTimer.current = setTimeout(() => {
                 const translateValue = getTranslate(drawerRef.current, direction);
                 set(drawerRef.current, {
                     transition: 'none',
@@ -1350,10 +1380,10 @@ function Root({ open: openProp, onOpenChange, children, onDrag: onDragProp, onRe
             });
         }
     }
-    React__namespace.default.useEffect(()=>{
+    React__namespace.default.useEffect(() => {
         if (!modal) {
             // Need to do this manually unfortunately
-            window.requestAnimationFrame(()=>{
+            window.requestAnimationFrame(() => {
                 document.body.style.pointerEvents = 'auto';
             });
         }
@@ -1362,7 +1392,7 @@ function Root({ open: openProp, onOpenChange, children, onDrag: onDragProp, onRe
     ]);
     return /*#__PURE__*/ React__namespace.default.createElement(DialogPrimitive__namespace.Root, {
         defaultOpen: defaultOpen,
-        onOpenChange: (open)=>{
+        onOpenChange: (open) => {
             if (!dismissible && !open) return;
             if (open) {
                 setHasBeenOpened(true);
@@ -1406,7 +1436,7 @@ function Root({ open: openProp, onOpenChange, children, onDrag: onDragProp, onRe
         }
     }, children));
 }
-const Overlay = /*#__PURE__*/ React__namespace.default.forwardRef(function({ ...rest }, ref) {
+const Overlay = /*#__PURE__*/ React__namespace.default.forwardRef(function ({ ...rest }, ref) {
     const { overlayRef, snapPoints, onRelease, shouldFade, isOpen, modal, shouldAnimate } = useDrawerContext();
     const composedRef = useComposedRefs(ref, overlayRef);
     const hasSnapPoints = snapPoints && snapPoints.length > 0;
@@ -1414,7 +1444,7 @@ const Overlay = /*#__PURE__*/ React__namespace.default.forwardRef(function({ ...
     if (!modal) {
         return null;
     }
-    const onMouseUp = React__namespace.default.useCallback((event)=>onRelease(event), [
+    const onMouseUp = React__namespace.default.useCallback((event) => onRelease(event), [
         onRelease
     ]);
     return /*#__PURE__*/ React__namespace.default.createElement(DialogPrimitive__namespace.Overlay, {
@@ -1428,7 +1458,7 @@ const Overlay = /*#__PURE__*/ React__namespace.default.forwardRef(function({ ...
     });
 });
 Overlay.displayName = 'Drawer.Overlay';
-const Content = /*#__PURE__*/ React__namespace.default.forwardRef(function({ onPointerDownOutside, style, onOpenAutoFocus, ...rest }, ref) {
+const Content = /*#__PURE__*/ React__namespace.default.forwardRef(function ({ onPointerDownOutside, style, onOpenAutoFocus, ...rest }, ref) {
     const { drawerRef, onPress, onRelease, onDrag, keyboardIsOpen, snapPointsOffset, activeSnapPointIndex, modal, isOpen, direction, snapPoints, container, handleOnly, shouldAnimate, autoFocus } = useDrawerContext();
     // Needed to use transition instead of animations
     const [delayedSnapPoints, setDelayedSnapPoints] = React__namespace.default.useState(false);
@@ -1438,7 +1468,7 @@ const Content = /*#__PURE__*/ React__namespace.default.forwardRef(function({ onP
     const wasBeyondThePointRef = React__namespace.default.useRef(false);
     const hasSnapPoints = snapPoints && snapPoints.length > 0;
     useScaleBackground();
-    const isDeltaInDirection = (delta, direction, threshold = 0)=>{
+    const isDeltaInDirection = (delta, direction, threshold = 0) => {
         if (wasBeyondThePointRef.current) return true;
         const deltaY = Math.abs(delta.y);
         const deltaX = Math.abs(delta.x);
@@ -1461,9 +1491,9 @@ const Content = /*#__PURE__*/ React__namespace.default.forwardRef(function({ onP
         wasBeyondThePointRef.current = true;
         return true;
     };
-    React__namespace.default.useEffect(()=>{
+    React__namespace.default.useEffect(() => {
         if (hasSnapPoints) {
-            window.requestAnimationFrame(()=>{
+            window.requestAnimationFrame(() => {
                 setDelayedSnapPoints(true);
             });
         }
@@ -1486,7 +1516,7 @@ const Content = /*#__PURE__*/ React__namespace.default.forwardRef(function({ onP
             '--snap-point-height': `${snapPointsOffset[activeSnapPointIndex != null ? activeSnapPointIndex : 0]}px`,
             ...style
         } : style,
-        onPointerDown: (event)=>{
+        onPointerDown: (event) => {
             if (handleOnly) return;
             rest.onPointerDown == null ? void 0 : rest.onPointerDown.call(rest, event);
             pointerStartRef.current = {
@@ -1495,13 +1525,13 @@ const Content = /*#__PURE__*/ React__namespace.default.forwardRef(function({ onP
             };
             onPress(event);
         },
-        onOpenAutoFocus: (e)=>{
+        onOpenAutoFocus: (e) => {
             onOpenAutoFocus == null ? void 0 : onOpenAutoFocus(e);
             if (!autoFocus) {
                 e.preventDefault();
             }
         },
-        onPointerDownOutside: (e)=>{
+        onPointerDownOutside: (e) => {
             onPointerDownOutside == null ? void 0 : onPointerDownOutside(e);
             if (!modal || e.defaultPrevented) {
                 e.preventDefault();
@@ -1511,13 +1541,13 @@ const Content = /*#__PURE__*/ React__namespace.default.forwardRef(function({ onP
                 keyboardIsOpen.current = false;
             }
         },
-        onFocusOutside: (e)=>{
+        onFocusOutside: (e) => {
             if (!modal) {
                 e.preventDefault();
                 return;
             }
         },
-        onPointerMove: (event)=>{
+        onPointerMove: (event) => {
             lastKnownPointerEventRef.current = event;
             if (handleOnly) return;
             rest.onPointerMove == null ? void 0 : rest.onPointerMove.call(rest, event);
@@ -1535,17 +1565,17 @@ const Content = /*#__PURE__*/ React__namespace.default.forwardRef(function({ onP
                 pointerStartRef.current = null;
             }
         },
-        onPointerUp: (event)=>{
+        onPointerUp: (event) => {
             rest.onPointerUp == null ? void 0 : rest.onPointerUp.call(rest, event);
             pointerStartRef.current = null;
             wasBeyondThePointRef.current = false;
             onRelease(event);
         },
-        onPointerOut: (event)=>{
+        onPointerOut: (event) => {
             rest.onPointerOut == null ? void 0 : rest.onPointerOut.call(rest, event);
             handleOnPointerUp(lastKnownPointerEventRef.current);
         },
-        onContextMenu: (event)=>{
+        onContextMenu: (event) => {
             rest.onContextMenu == null ? void 0 : rest.onContextMenu.call(rest, event);
             if (lastKnownPointerEventRef.current) {
                 handleOnPointerUp(lastKnownPointerEventRef.current);
@@ -1556,7 +1586,7 @@ const Content = /*#__PURE__*/ React__namespace.default.forwardRef(function({ onP
 Content.displayName = 'Drawer.Content';
 const LONG_HANDLE_PRESS_TIMEOUT = 250;
 const DOUBLE_TAP_TIMEOUT = 120;
-const Handle = /*#__PURE__*/ React__namespace.default.forwardRef(function({ preventCycle = false, children, ...rest }, ref) {
+const Handle = /*#__PURE__*/ React__namespace.default.forwardRef(function ({ preventCycle = false, children, ...rest }, ref) {
     const { closeDrawer, isDragging, snapPoints, activeSnapPoint, setActiveSnapPoint, dismissible, handleOnly, isOpen, onPress, onDrag } = useDrawerContext();
     const closeTimeoutIdRef = React__namespace.default.useRef(null);
     const shouldCancelInteractionRef = React__namespace.default.useRef(false);
@@ -1566,7 +1596,7 @@ const Handle = /*#__PURE__*/ React__namespace.default.forwardRef(function({ prev
             handleCancelInteraction();
             return;
         }
-        window.setTimeout(()=>{
+        window.setTimeout(() => {
             handleCycleSnapPoints();
         }, DOUBLE_TAP_TIMEOUT);
     }
@@ -1589,13 +1619,13 @@ const Handle = /*#__PURE__*/ React__namespace.default.forwardRef(function({ prev
             closeDrawer();
             return;
         }
-        const currentSnapIndex = snapPoints.findIndex((point)=>point === activeSnapPoint);
+        const currentSnapIndex = snapPoints.findIndex((point) => point === activeSnapPoint);
         if (currentSnapIndex === -1) return; // activeSnapPoint not found in snapPoints
         const nextSnapPoint = snapPoints[currentSnapIndex + 1];
         setActiveSnapPoint(nextSnapPoint);
     }
     function handleStartInteraction() {
-        closeTimeoutIdRef.current = window.setTimeout(()=>{
+        closeTimeoutIdRef.current = window.setTimeout(() => {
             // Cancel click interaction on a long press
             shouldCancelInteractionRef.current = true;
         }, LONG_HANDLE_PRESS_TIMEOUT);
@@ -1609,11 +1639,11 @@ const Handle = /*#__PURE__*/ React__namespace.default.forwardRef(function({ prev
     return /*#__PURE__*/ React__namespace.default.createElement("div", {
         onClick: handleStartCycle,
         onPointerCancel: handleCancelInteraction,
-        onPointerDown: (e)=>{
+        onPointerDown: (e) => {
             if (handleOnly) onPress(e);
             handleStartInteraction();
         },
-        onPointerMove: (e)=>{
+        onPointerMove: (e) => {
             if (handleOnly) onDrag(e);
         },
         // onPointerUp is already handled by the content component
@@ -1635,14 +1665,14 @@ function NestedRoot({ onDrag, onOpenChange, ...rest }) {
     }
     return /*#__PURE__*/ React__namespace.default.createElement(Root, {
         nested: true,
-        onClose: ()=>{
+        onClose: () => {
             onNestedOpenChange(false);
         },
-        onDrag: (e, p)=>{
+        onDrag: (e, p) => {
             onNestedDrag(e, p);
             onDrag == null ? void 0 : onDrag(e, p);
         },
-        onOpenChange: (o)=>{
+        onOpenChange: (o) => {
             if (o) {
                 onNestedOpenChange(o);
             }
diff --git a/node_modules/vaul/dist/index.mjs b/node_modules/vaul/dist/index.mjs
index 39b07ab..96524ed 100644
--- a/node_modules/vaul/dist/index.mjs
+++ b/node_modules/vaul/dist/index.mjs
@@ -1109,67 +1109,101 @@ function Root({ open: openProp, onOpenChange, children, onDrag: onDragProp, onRe
             shouldAnimate.current = true;
         });
     }, []);
-    React__default.useEffect(()=>{
-        var _window_visualViewport;
+    React.useEffect(() => {
         function onVisualViewportChange() {
             if (!drawerRef.current || !repositionInputs) return;
+
             const focusedElement = document.activeElement;
+            // If the focused element is an input OR we've detected the keyboard is open,
+            // then proceed to measure and possibly reposition the drawer
             if (isInput(focusedElement) || keyboardIsOpen.current) {
-                var _window_visualViewport;
-                const visualViewportHeight = ((_window_visualViewport = window.visualViewport) == null ? void 0 : _window_visualViewport.height) || 0;
+                const visualViewportHeight = window.visualViewport?.height || 0;
                 const totalHeight = window.innerHeight;
-                // This is the height of the keyboard
-                let diffFromInitial = totalHeight - visualViewportHeight;
                 const drawerHeight = drawerRef.current.getBoundingClientRect().height || 0;
-                // Adjust drawer height only if it's tall enough
-                const isTallEnough = drawerHeight > totalHeight * 0.8;
-                if (!initialDrawerHeight.current) {
-                    initialDrawerHeight.current = drawerHeight;
-                }
-                const offsetFromTop = drawerRef.current.getBoundingClientRect().top;
-                // visualViewport height may change due to somq e subtle changes to the keyboard. Checking if the height changed by 60 or more will make sure that they keyboard really changed its open state.
-                if (Math.abs(previousDiffFromInitial.current - diffFromInitial) > 60) {
-                    keyboardIsOpen.current = !keyboardIsOpen.current;
-                }
-                if (snapPoints && snapPoints.length > 0 && snapPointsOffset && activeSnapPointIndex) {
+
+                // This is the "keyboard height" difference
+                let diffFromInitial = totalHeight - visualViewportHeight;
+
+                // If we have snapPoints, adjust diffFromInitial accordingly
+                if (snapPoints && snapPoints.length > 0 && snapPointsOffset && activeSnapPointIndex !== undefined) {
                     const activeSnapPointHeight = snapPointsOffset[activeSnapPointIndex] || 0;
                     diffFromInitial += activeSnapPointHeight;
                 }
+
+                // We treat a non-negligible diff as "keyboard open"
+                // (for example, anything more than ~60px might indicate a fully opened keyboard,
+                // but if we want to capture *any* keyboard shift, we can lower this threshold.)
+                const KEYBOARD_OPEN_THRESHOLD = 20;
+                keyboardIsOpen.current = diffFromInitial > KEYBOARD_OPEN_THRESHOLD;
+
+                // Store the updated diff
                 previousDiffFromInitial.current = diffFromInitial;
-                // We don't have to change the height if the input is in view, when we are here we are in the opened keyboard state so we can correctly check if the input is in view
+
+                // If we haven’t stored the initial drawer height yet, store it
+                if (!initialDrawerHeight.current) {
+                    initialDrawerHeight.current = drawerHeight;
+                }
+
+                const offsetFromTop = drawerRef.current.getBoundingClientRect().top;
+                const isTallEnough = drawerHeight > totalHeight * 0.8;
+
+                // Check if the drawer should be “shrunk” or repositioned
+                // whenever the keyboard is open or the drawer is taller than the viewport
                 if (drawerHeight > visualViewportHeight || keyboardIsOpen.current) {
-                    const height = drawerRef.current.getBoundingClientRect().height;
-                    let newDrawerHeight = height;
-                    if (height > visualViewportHeight) {
+                    const currentHeight = drawerRef.current.getBoundingClientRect().height;
+                    let newDrawerHeight = currentHeight;
+
+                    // If the drawer is taller than the visible viewport, shrink it
+                    if (currentHeight > visualViewportHeight) {
+                        // Use either a top offset-based calculation if tall enough,
+                        // or a constant offset if not.
                         newDrawerHeight = visualViewportHeight - (isTallEnough ? offsetFromTop : WINDOW_TOP_OFFSET);
                     }
-                    // When fixed, don't move the drawer upwards if there's space, but rather only change it's height so it's fully scrollable when the keyboard is open
+
                     if (fixed) {
-                        drawerRef.current.style.height = `${height - Math.max(diffFromInitial, 0)}px`;
+                        // “fixed” logic: only change the height, so the user can scroll inside
+                        // the drawer if needed.
+                        drawerRef.current.style.height = `${currentHeight - Math.max(diffFromInitial, 0)}px`;
                     } else {
+                        // “absolute/relative” logic: set the drawer height so it remains
+                        // fully within the viewport. We also ensure the drawer can’t become
+                        // smaller than (viewport height - offsetFromTop)
                         drawerRef.current.style.height = `${Math.max(newDrawerHeight, visualViewportHeight - offsetFromTop)}px`;
                     }
-                } else if (!isMobileFirefox()) {
+                }
+                // If the keyboard is closed and we’re not Firefox Mobile, reset back 
+                // to original height
+                else if (!isMobileFirefox()) {
                     drawerRef.current.style.height = `${initialDrawerHeight.current}px`;
                 }
+
+                // Update bottom offset
                 if (snapPoints && snapPoints.length > 0 && !keyboardIsOpen.current) {
+                    // If the keyboard is closed, align the drawer bottom to 0
                     drawerRef.current.style.bottom = `0px`;
                 } else {
-                    // Negative bottom value would never make sense
+                    // If the keyboard is open, push the bottom up by diffFromInitial
+                    // but never let it go negative
                     drawerRef.current.style.bottom = `${Math.max(diffFromInitial, 0)}px`;
                 }
             }
         }
-        (_window_visualViewport = window.visualViewport) == null ? void 0 : _window_visualViewport.addEventListener('resize', onVisualViewportChange);
-        return ()=>{
-            var _window_visualViewport;
-            return (_window_visualViewport = window.visualViewport) == null ? void 0 : _window_visualViewport.removeEventListener('resize', onVisualViewportChange);
+
+        // Attach the event listener
+        window.visualViewport?.addEventListener('resize', onVisualViewportChange);
+
+        return () => {
+            // Cleanup
+            window.visualViewport?.removeEventListener('resize', onVisualViewportChange);
         };
     }, [
         activeSnapPointIndex,
         snapPoints,
-        snapPointsOffset
+        snapPointsOffset,
+        repositionInputs,
+        fixed
     ]);
+
     function closeDrawer(fromWithin) {
         cancelDrag();
         onClose == null ? void 0 : onClose();
